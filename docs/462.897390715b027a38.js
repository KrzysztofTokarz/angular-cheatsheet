"use strict";(self.webpackChunkangular_cheatsheet=self.webpackChunkangular_cheatsheet||[]).push([[462],{3462:(T,p,s)=>{s.r(p),s.d(p,{default:()=>A});var i=s(6814),n=s(5879),r=s(1993),l=s(95),d=s(6742),g=s(9849),m=s(5303),h=s(1687);let C=(()=>{class e{constructor(){(0,n.cEC)(a=>{const t=(0,h.F)(1e3).subscribe(()=>{console.log("i`m interval from signals cleanup component")});a(()=>{t.unsubscribe()})})}}return e.\u0275fac=function(a){return new(a||e)},e.\u0275cmp=n.Xpm({type:e,selectors:[["app-signals-cleanup"]],standalone:!0,features:[n.jDz],decls:2,vars:0,template:function(a,t){1&a&&(n.TgZ(0,"p"),n._uU(1,"signals-cleanup works!"),n.qZA())},dependencies:[i.ez],styles:["[_nghost-%COMP%]{display:block}"]}),e})();function f(e,o){1&e&&n._UZ(0,"app-signals-cleanup",5)}const Z=(e,o)=>JSON.stringify(e)===JSON.stringify(o);let v=(()=>{class e{constructor(){this.equalitySignal=(0,n.tdS)({id:1,name:"Adam"},{equal:Z}),this.trackedInputValue=(0,n.tdS)("I`m tracked"),this.untrackedInputValue=(0,n.tdS)("I`m untracked"),this.showCleanupComp=!1,(0,n.cEC)(()=>{console.log("------------ Advanced topics ------------"),console.log(`I will run only on init because of equality function ${JSON.stringify(this.equalitySignal())}`)}),(0,n.cEC)(()=>{console.log(`I will run only on first input value change change - ${this.trackedInputValue()} ${(0,n.rg0)(this.untrackedInputValue)}`)})}setEqualObject(){this.equalitySignal.set({id:1,name:"Adam"})}}return e.\u0275fac=function(a){return new(a||e)},e.\u0275cmp=n.Xpm({type:e,selectors:[["app-signals-advanced-topics"]],standalone:!0,features:[n.jDz],decls:19,vars:3,consts:[[3,"click"],[1,"mt-4"],[1,"me-2",3,"ngModel","ngModelChange"],[3,"ngModel","ngModelChange"],["class","mt-2",4,"ngIf"],[1,"mt-2"]],template:function(a,t){1&a&&(n.TgZ(0,"p"),n._uU(1," Signals allows us to use equality function to compare values and determine if we need an update or not, click the button below and check that we "),n.TgZ(2,"strong"),n._uU(3,"don`t have"),n.qZA(),n._uU(4," new logs in the console from the effect\n"),n.qZA(),n.TgZ(5,"app-button",0),n.NdJ("click",function(){return t.setEqualObject()}),n._uU(6,"Set equal object"),n.qZA(),n.TgZ(7,"p",1),n._uU(8,"Sometimes we need to read value of signal inside of effect, but do not track it`s value, then we can use "),n.TgZ(9,"strong"),n._uU(10,"untracked()"),n.qZA(),n._uU(11," function to mark signal as untracked"),n.qZA(),n.TgZ(12,"app-input",2),n.NdJ("ngModelChange",function(c){return t.trackedInputValue.set(c)}),n.qZA(),n.TgZ(13,"app-input",3),n.NdJ("ngModelChange",function(c){return t.untrackedInputValue.set(c)}),n.qZA(),n.TgZ(14,"p",1),n._uU(15,"Effects has also cleanUp function as their first parameter inside of a callback"),n.qZA(),n.TgZ(16,"app-button",0),n.NdJ("click",function(){return t.showCleanupComp=!t.showCleanupComp}),n._uU(17,"Show/hide component"),n.qZA(),n.YNc(18,f,1,0,"app-signals-cleanup",4)),2&a&&(n.xp6(12),n.Q6J("ngModel",t.trackedInputValue()),n.xp6(1),n.Q6J("ngModel",t.untrackedInputValue()),n.xp6(5),n.Q6J("ngIf",t.showCleanupComp))},dependencies:[i.ez,i.O5,d.r,g.a,l.u5,l.JJ,l.On,C],styles:["[_nghost-%COMP%]{display:block}"]}),e})();const A=(()=>{class e{constructor(){this.counter=(0,n.tdS)(1),this.text=(0,n.tdS)("Some text"),this.doubleCounter=(0,n.Flj)(()=>2*this.counter()),this.staticCounter=2*this.counter(),this.textFromInputAndCounter=(0,n.Flj)(()=>`${this.text()} + ${this.counter()}`),this.counterObservable$=(0,r.Dx)(this.counter),this.counterSignal=(0,r.O4)(this.counterObservable$),(0,n.cEC)(()=>{console.log(`I will run on init and when counter changes - ${this.counter()}`)}),(0,n.cEC)(()=>{console.log(`I will run on init and when text changes - ${this.text()}`)}),(0,n.cEC)(()=>{console.log(`I will run on init and when counter or text changes - ${this.text()} + ${this.counter()}`)})}increment(){this.counter.update(a=>a+1)}}return e.\u0275fac=function(a){return new(a||e)},e.\u0275cmp=n.Xpm({type:e,selectors:[["app-signals"]],standalone:!0,features:[n.jDz],decls:27,vars:10,consts:[[3,"openConsole"],[3,"ngModel","ngModelChange"],[3,"click"],[1,"mt-5"]],template:function(a,t){1&a&&(n.TgZ(0,"p"),n._uU(1," A signal is a wrapper around a value that can notify interested consumers when that value changes. Signals can contain any value, from simple primitives to complex data structures.\n"),n.qZA(),n.TgZ(2,"p"),n._uU(3," A signal's value is always read through a getter function, which allows Angular to track where the signal is used.\n"),n.qZA(),n.TgZ(4,"p"),n._uU(5,"Signals may be either writable or read-only."),n.qZA(),n.TgZ(6,"app-live-example",0)(7,"div")(8,"app-input",1),n.NdJ("ngModelChange",function(c){return t.text.set(c)}),n.qZA(),n.TgZ(9,"p"),n._uU(10),n.qZA(),n.TgZ(11,"p"),n._uU(12),n.qZA(),n.TgZ(13,"p"),n._uU(14),n.qZA(),n.TgZ(15,"p"),n._uU(16),n.qZA(),n.TgZ(17,"p"),n._uU(18),n.ALo(19,"async"),n.qZA(),n.TgZ(20,"p"),n._uU(21),n.qZA()(),n.TgZ(22,"app-button",2),n.NdJ("click",function(){return t.increment()}),n._uU(23,"Increase counter"),n.qZA(),n.TgZ(24,"h3",3),n._uU(25,"Advanced topics examples:"),n.qZA(),n._UZ(26,"app-signals-advanced-topics"),n.qZA()),2&a&&(n.xp6(6),n.Q6J("openConsole",!0),n.xp6(2),n.Q6J("ngModel",t.text()),n.xp6(2),n.hij("I am the counter, click button below to increment me - ",t.counter(),""),n.xp6(2),n.hij("I am doubled counter - ",t.doubleCounter(),""),n.xp6(2),n.hij("I am the static counter, i will not increment - ",t.staticCounter,""),n.xp6(2),n.hij("I am computed text from input and counter - ",t.textFromInputAndCounter(),""),n.xp6(2),n.hij("I am the counter displayed as observable with async pipe - ",n.lcZ(19,8,t.counterObservable$),""),n.xp6(3),n.hij("I am the counter converted to signal from observable - ",t.counterSignal(),""))},dependencies:[i.ez,i.Ov,d.r,g.a,l.u5,l.JJ,l.On,v,m.s],styles:["[_nghost-%COMP%]{display:block}"]}),e})()}}]);